package sk.upjs.ics.presov.opendata.provider;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.os.Bundle;
import android.support.annotation.Nullable;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static android.content.ContentResolver.SCHEME_CONTENT;
import static sk.upjs.ics.presov.opendata.Defaults.AUTOGENERATED_ID;
import static sk.upjs.ics.presov.opendata.Defaults.NO_BUNDLE;
import static sk.upjs.ics.presov.opendata.Defaults.NO_CURSOR;
import static sk.upjs.ics.presov.opendata.Defaults.NO_GROUP_BY;
import static sk.upjs.ics.presov.opendata.Defaults.NO_HAVING;
import static sk.upjs.ics.presov.opendata.Defaults.NO_NULL_COLUMN_HACK;
import static sk.upjs.ics.presov.opendata.Defaults.NO_TYPE;
import static sk.upjs.ics.presov.opendata.Defaults.NO_URI;

public class DatasetContentProvider extends ContentProvider {

    public static final String AUTHORITY = "sk.upjs.ics.presov.opendata.provider.DatasetContentProvider";

    public static final String CREATE_TABLE_ROWS_METHOD = "createTableRows";

    public static final String CREATE_TABLE_COLUMNS_METHOD = "createTableColumns";

    public static final String REMOVE_TABLE_ROWS_METHOD = "removeTableRows";

    public static final String REMOVE_TABLE_COLUMNS_METHOD = "removeTableColumns";

    public static final String ID = "id";

    public static final String COLUMNS = "columns";

    public static final String ROWS = "rows";

    private UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    private static final int URI_MATCH_ROWS = 0;

    private static final int URI_MATCH_COLUMNS = 1;

    private DatabaseOpenHelper databaseOpenHelper;

    public DatasetContentProvider() {

    }

    public static Uri RowsContentUri(long id) {
        return new Uri.Builder()
                .scheme(SCHEME_CONTENT)
                .authority(AUTHORITY)
                .appendPath(ROWS)
                .appendPath(String.valueOf(id))
                .build();
    }

    public static Uri ColumnsContentUri(long id) {
        return new Uri.Builder()
                .scheme(SCHEME_CONTENT)
                .authority(AUTHORITY)
                .appendPath(COLUMNS)
                .appendPath(String.valueOf(id))
                .build();
    }

    @Override
    public boolean onCreate() {
        this.databaseOpenHelper = new DatabaseOpenHelper(getContext());

        uriMatcher.addURI(AUTHORITY, ROWS + "/#", URI_MATCH_ROWS);
        uriMatcher.addURI(AUTHORITY, COLUMNS + "/#", URI_MATCH_COLUMNS);

        return true;
    }


    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        // Implement this to handle requests to delete one or more rows.
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Override
    public String getType(Uri uri) {
        switch (uriMatcher.match(uri)) {
            case URI_MATCH_ROWS:
                return ContentResolver.CURSOR_DIR_BASE_TYPE + "/vnd." + AUTHORITY + "." + Provider.Rows.rowsTableName(uri);
            case URI_MATCH_COLUMNS:
                return ContentResolver.CURSOR_DIR_BASE_TYPE + "/vnd." + AUTHORITY + "." + Provider.Columns.columnsTableName(uri);
            default:
                return NO_TYPE;
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        switch (uriMatcher.match(uri)) {
            case URI_MATCH_ROWS:
                return saveRow(uri, values);
            case URI_MATCH_COLUMNS:
                return saveColumn(uri, values);
            default:
                return NO_URI;
        }
    }

    private Uri saveRow(Uri uri, ContentValues values) {
        ContentValues row = new ContentValues();
        row.put(Provider.Rows._ID, AUTOGENERATED_ID);
        for (String key : values.keySet()) {
            row.put(key, values.getAsString(key));
        }

        SQLiteDatabase db = this.databaseOpenHelper.getWritableDatabase();
        long newId = db.insert(Provider.Rows.rowsTableName(uri), NO_NULL_COLUMN_HACK, row);
        return ContentUris.withAppendedId(uri, newId);
    }

    private Uri saveColumn(Uri uri, ContentValues values) {
        ContentValues column = new ContentValues();
        column.put(Provider.Columns._ID, AUTOGENERATED_ID);
        for (String key : values.keySet()) {
            column.put(key, values.getAsString(key));
        }

        SQLiteDatabase db = this.databaseOpenHelper.getWritableDatabase();
        long newId = db.insert(Provider.Columns.columnsTableName(uri), NO_NULL_COLUMN_HACK, column);
        return ContentUris.withAppendedId(uri, newId);
    }

    @Nullable
    @Override
    public Bundle call(String method, String arg, Bundle extras) {
        SQLiteDatabase db = this.databaseOpenHelper.getWritableDatabase();
        long id = extras.getLong(ID);
        if (CREATE_TABLE_ROWS_METHOD.equals(method)) {
            Set<String> columns = new HashSet<>(Arrays.asList(extras.getStringArray(COLUMNS)));
            this.databaseOpenHelper.dropRowsTable(db, id);
            this.databaseOpenHelper.createRowsTable(db, id, columns);
        }
        if (CREATE_TABLE_COLUMNS_METHOD.equals(method)) {
            this.databaseOpenHelper.dropColumnsTable(db, id);
            this.databaseOpenHelper.createColumnsTable(db, id);
        }
        if (REMOVE_TABLE_COLUMNS_METHOD.equals(method)) {
            this.databaseOpenHelper.dropColumnsTable(db, id);
        }
        if (REMOVE_TABLE_ROWS_METHOD.equals(method)) {
            this.databaseOpenHelper.dropRowsTable(db, id);
        }

        return NO_BUNDLE;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
                        String[] selectionArgs, String sortOrder) {
        SQLiteDatabase db = databaseOpenHelper.getReadableDatabase();
        switch (uriMatcher.match(uri)) {
            case URI_MATCH_ROWS:
                return db.query(Provider.Rows.rowsTableName(uri), projection, selection, selectionArgs, NO_GROUP_BY, NO_HAVING, sortOrder);
            case URI_MATCH_COLUMNS:
                return db.query(Provider.Columns.columnsTableName(uri), projection, selection, selectionArgs, NO_GROUP_BY, NO_HAVING, sortOrder);
            default:
                return NO_CURSOR;
        }
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
                      String[] selectionArgs) {
        // TODO: Implement this to handle requests to update one or more rows.
        throw new UnsupportedOperationException("Not yet implemented");
    }
}
